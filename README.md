# de-jai'
jai' - automation intelligence

# purpose: 
de-jai' is (just another) attempt at creating a self-regulating software engine with a survival instinct. the purpose of this software is for it be a distributed-engine with an identity goal and a survival instinct - de-jai's prime directive is to extend its own mortality and to preserve state.  secondarily, de-jai\` aggregates and processes data as a self-aware, self-healing, self-scaling,  process-cache and distributed-compute grid. 

# how it works:
the system is a self-organizing swarm of stateful and stateless nodes deployed as a distributed-graph. each node is an identical meta-machine; the node is an index-entry into a distributed, multi-dimensional distributed-versioned hash map; this is a critical point to understanding why de-jai' works. conceptually, the swarm is a 'self-sorting 'nth-tree' that incorporates synchronous-asynchronous, parent-child, active-passive, produce-consumer and other important attributes into a configurable model. a node is a programmable, verifiable data file that executes configurable algorithms. it is also self-healing and has a built-in 'swarm-survival' instinct.

it helps to visualize de-'jai as n-dimensional maps of n-dimensional maps.

## model:
Node<?> node = new Node<Node>();

## control:
each node in the swarm is essentially a meta-processor that provides both the ability to store and process data supplied to it. it is aware of it's membership in the larger system and is cooperative by nature.      


## D - istributed
## E - ngine
## -
## J - (just another) 
## A - utomation
## I - ntelligence
## '

# background:
What if modern software systems were programmed on-top of a self-scaling-infrastructure orchestrated by a compute-process-store controlled by 'purposed' software ??? I you would have a machine whose primary missions are to:

* compute: keep its own compute-clusters running (program it with a drive to survive and gift it with protected cloud resources)
* store: maintain, store,  and execute its own self-learning software (give it a reason to survive, something to remember, the ability to learn, and the ability to synthesize)
and;
* choose: use a 'rules/no-rules'  decision trees and occasionally choose one at random  (motivation - give the machine a way to self-learn) and to develop it's own filters)

I think that's the general blueprint on how to architect a true machine intelligence.  It's easy really, all you need is secure compute and communication clouds with guaranteed power and a self-healing auto-scaling grid

In the real world, that kind of system is pretty much there (there is a lot of blur between governments, infrastructure, the cloud industry, and business and it's hard to tell what is what any more. But we have probably already created machine intelligence, and likely aren't even aware of it.

# getting started: 
The first thing you need to do is to visit this web-site and understand the architecture of the de'jai' distributed intelligent system. 

When you are done and answer a question or ten you will receive the key you need to join the project.   

# web site:
Web Site: iDynaTECH.com (http://dejai.idynatech.net:23032/?)
 